---
phase: 01-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Dockerfile
  - docker-compose.yml
  - .dockerignore
  - .env.example
autonomous: true

must_haves:
  truths:
    - "docker compose up starts the development environment"
    - "Next.js runs on port 3400 (mapped from container 3000)"
    - "Code changes on host reflect immediately in running container"
    - "No need to run bun dev directly on host machine"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage Docker build configuration"
      contains: "FROM oven/bun"
    - path: "docker-compose.yml"
      provides: "Service orchestration for development"
      contains: "jpgerton-frontend"
    - path: ".dockerignore"
      provides: "Build context exclusions"
      contains: "node_modules"
    - path: ".env.example"
      provides: "Environment variable template"
      contains: "NEXT_PUBLIC_CONVEX_URL"
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:"
    - from: "docker-compose.yml"
      to: ".env"
      via: "environment variables"
      pattern: "env_file"
---

<objective>
Create Dockerized development environment with hot reload.

Purpose: All development runs through Docker containers with live code updates - mandatory project requirement.
Output: Working Docker Compose setup that starts Next.js on port 3400 with volume mounts for hot reload.
</objective>

<execution_context>
@C:\Users\jonge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jonge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-infrastructure/01-CONTEXT.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage Dockerfile</name>
  <files>
    Dockerfile
  </files>
  <action>
    Create Dockerfile with stages for development and production:

    ```dockerfile
    # Development stage (target: dev)
    FROM oven/bun:1 AS dev
    WORKDIR /app
    EXPOSE 3000
    CMD ["bun", "--bun", "run", "dev"]

    # Dependencies stage
    FROM oven/bun:1 AS deps
    WORKDIR /app
    COPY package.json bun.lockb ./
    RUN bun install --frozen-lockfile

    # Build stage
    FROM oven/bun:1 AS build
    WORKDIR /app
    COPY --from=deps /app/node_modules ./node_modules
    COPY . .
    ENV NEXT_TELEMETRY_DISABLED=1
    RUN bun run build

    # Production stage
    FROM oven/bun:1-alpine AS production
    WORKDIR /app
    ENV NODE_ENV=production
    ENV NEXT_TELEMETRY_DISABLED=1
    COPY --from=build /app/package.json ./package.json
    COPY --from=build /app/bun.lockb ./bun.lockb
    COPY --from=build /app/next.config.js ./
    COPY --from=build /app/public ./public
    COPY --from=build /app/.next ./.next
    RUN bun install --frozen-lockfile --production
    EXPOSE 3000
    CMD ["bun", "run", "start"]
    ```

    Key aspects:
    - dev stage: Minimal, for docker-compose bind mounts
    - deps stage: Separate layer for dependency caching
    - build stage: Full build for production
    - production stage: Alpine-based for smaller image
    - Uses oven/bun:1 official image (not node)
  </action>
  <verify>
    File exists at Dockerfile
    Contains all 4 stages: dev, deps, build, production
  </verify>
  <done>
    Multi-stage Dockerfile exists with dev stage for local development and production stage for deployment
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker Compose and environment files</name>
  <files>
    docker-compose.yml
    .dockerignore
    .env.example
  </files>
  <action>
    Create docker-compose.yml:

    ```yaml
    version: '3.8'

    services:
      frontend:
        build:
          context: .
          target: dev
        container_name: jpgerton-frontend
        ports:
          - "3400:3000"
        volumes:
          - .:/app
          - /app/node_modules
          - /app/.next
        environment:
          - WATCHPACK_POLLING=true
          - CHOKIDAR_USEPOLLING=true
          - NEXT_PUBLIC_CONVEX_URL=${NEXT_PUBLIC_CONVEX_URL}
        env_file:
          - .env.local
        networks:
          - jpgerton-network
        command: bun --bun run dev

    networks:
      jpgerton-network:
        name: jpgerton-network
    ```

    Key aspects per CONTEXT.md decisions:
    - Container name: jpgerton-frontend (jpgerton-* prefix)
    - Port: 3400:3000 (3400 external, 3000 internal)
    - Network: jpgerton-network (single network)
    - WATCHPACK_POLLING=true for hot reload in Docker
    - Volume mounts: Bind mount entire project, anonymous volumes for node_modules and .next
    - env_file points to .env.local (will be created)

    Create .dockerignore:
    ```
    node_modules
    .next
    .git
    .gitignore
    .env*
    !.env.example
    README.md
    LICENSE
    .vscode
    .idea
    *.log
    npm-debug.log*
    yarn-debug.log*
    yarn-error.log*
    .DS_Store
    *.swp
    *.swo
    coverage
    .cache
    dist
    build
    .planning
    docs
    ```

    Create .env.example:
    ```
    # Convex (required)
    NEXT_PUBLIC_CONVEX_URL=https://your-deployment.convex.cloud

    # Optional: Convex deployment name for CLI
    CONVEX_DEPLOYMENT=your-deployment-name
    ```

    Create .env.local (gitignored, copy from example):
    ```
    NEXT_PUBLIC_CONVEX_URL=
    CONVEX_DEPLOYMENT=
    ```

    Update .gitignore to ensure .env.local is ignored but .env.example is not.
  </action>
  <verify>
    `docker compose config` parses without errors
    .dockerignore exists and excludes node_modules
    .env.example exists with documented variables
  </verify>
  <done>
    Docker Compose configured with jpgerton naming conventions, port 3400, and hot reload environment variables
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Docker development environment</name>
  <files>None (verification only)</files>
  <action>
    1. Build and start the development container:
       `docker compose up --build`

    2. Wait for Next.js to compile (watch for "Ready" message in logs)

    3. In a new terminal, verify the app is accessible:
       `curl -I http://localhost:3400` should return 200 OK

    4. Test hot reload:
       - Make a visible change to app/page.tsx (e.g., change h1 text)
       - Save the file
       - Watch container logs for recompilation
       - Verify change appears at http://localhost:3400

    5. Stop containers:
       `docker compose down`

    6. Commit Docker configuration:
       `git add Dockerfile docker-compose.yml .dockerignore .env.example`
       `git commit -m "feat(infra): add Docker development environment

       - Multi-stage Dockerfile (dev, deps, build, production)
       - Docker Compose with hot reload via WATCHPACK_POLLING
       - Port mapping: 3400 -> 3000
       - Volume mounts for live code updates"`
  </action>
  <verify>
    `docker compose up --build` starts successfully
    http://localhost:3400 returns Next.js page
    File changes trigger recompilation in container logs
  </verify>
  <done>
    Docker development environment works with hot reload, committed to develop branch
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `docker compose up` starts jpgerton-frontend container
2. http://localhost:3400 serves Next.js app
3. Editing app/page.tsx triggers recompilation
4. `docker compose down` cleans up
5. All Docker files committed to develop branch
</verification>

<success_criteria>
- docker compose up starts development environment on port 3400
- Hot reload works (code changes reflect without rebuild)
- No bun/npm commands needed on host (all through Docker)
- Container uses jpgerton-frontend name per conventions
- Ready for Convex integration in Plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-02-SUMMARY.md`
</output>
