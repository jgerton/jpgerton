---
phase: 15-content-schema-backend
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - convex/blogPosts.ts
  - convex/caseStudies.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create a blog post with title, excerpt, content, category, and optional cover image"
    - "Blog post auto-generates URL-safe slug from title with manual override"
    - "Slug collisions automatically append numeric suffix (my-post, my-post-2, my-post-3)"
    - "Blog post can be saved as draft or published with publishedAt timestamp"
    - "Published blog post slug cannot be changed"
    - "Blog posts support soft delete and restore"
    - "Admin can create a case study with optional project link and problem/solution/results sections"
    - "Case study has structured metrics (label + value pairs)"
    - "Public queries filter out deleted content and only return published items"
    - "All mutations require authentication via getAuthUserId"
    - "Reading time is computed from word count in blog post queries"
  artifacts:
    - path: "convex/blogPosts.ts"
      provides: "Complete blog post CRUD with slug generation, publishing, soft delete"
      exports: ["list", "listPublished", "getBySlug", "getById", "create", "update", "publish", "unpublish", "remove", "restore", "reorder", "generateUploadUrl"]
    - path: "convex/caseStudies.ts"
      provides: "Complete case study CRUD with project linking, metrics, publishing"
      exports: ["list", "listPublished", "getBySlug", "getByProject", "getById", "create", "update", "publish", "unpublish", "remove", "restore", "reorder", "generateUploadUrl"]
  key_links:
    - from: "convex/blogPosts.ts"
      to: "convex/schema.ts"
      via: "Convex typed queries reference blogPosts table"
      pattern: "ctx\\.db\\.query\\(\"blogPosts\"\\)"
    - from: "convex/caseStudies.ts"
      to: "convex/schema.ts"
      via: "Convex typed queries reference caseStudies table"
      pattern: "ctx\\.db\\.query\\(\"caseStudies\"\\)"
    - from: "convex/blogPosts.ts"
      to: "convex/auth.ts"
      via: "Auth check on all mutations"
      pattern: "getAuthUserId"
    - from: "convex/caseStudies.ts"
      to: "convex/auth.ts"
      via: "Auth check on all mutations"
      pattern: "getAuthUserId"
    - from: "convex/caseStudies.ts"
      to: "convex/schema.ts (projects table)"
      via: "Optional project reference for case study linking"
      pattern: "v\\.optional\\(v\\.id\\(\"projects\"\\)\\)"
---

<objective>
Create the complete Convex backend modules for blog posts and case studies with all queries, mutations, slug generation, publishing workflow, soft delete, and authentication.

Purpose: These two modules provide the full data layer that Phase 16 (admin UI) and Phase 17 (public pages) will consume. Every query and mutation needed for content management is defined here.
Output: Two new Convex modules (convex/blogPosts.ts, convex/caseStudies.ts) with complete CRUD operations.
</objective>

<execution_context>
@C:\Users\jonge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jonge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-content-schema-backend/15-CONTEXT.md
@.planning/phases/15-content-schema-backend/15-RESEARCH.md
@.planning/phases/15-content-schema-backend/15-01-SUMMARY.md
@convex/schema.ts
@convex/projects.ts
@convex/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create blog posts Convex module</name>
  <files>convex/blogPosts.ts</files>
  <action>
Create `convex/blogPosts.ts` following the exact patterns from `convex/projects.ts`. This file implements the complete blog post backend.

**Imports:**
```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { getAuthUserId } from "./auth";
import slugify from "slugify";
```

**Helper function (module-level, not exported):**

```typescript
function calculateReadingTime(content: string): number {
  const wordsPerMinute = 200;
  const wordCount = content.trim().split(/\s+/).length;
  return Math.max(1, Math.ceil(wordCount / wordsPerMinute));
}
```

**Queries to implement:**

1. `list` - Admin query (authenticated). Returns all non-deleted blog posts with optional status filter. Includes coverImageUrl resolution and readingTime computation. Sort by displayOrder ASC with _creationTime as tiebreaker.
   - Args: `{ status: v.optional(v.union(v.literal("draft"), v.literal("published"))) }`
   - Auth: Required (throws "Unauthorized")
   - Filter: `isDeleted === false`, then optionally by status arg
   - Returns: Array with `coverImageUrl` and `readingTime` fields added

2. `listPublished` - Public query (no auth). Returns only published, non-deleted blog posts. Includes coverImageUrl and readingTime. Sort by publishedAt DESC (newest first).
   - Args: `{ category: v.optional(v.union(v.literal("Local Business"), v.literal("Technical"), v.literal("Announcement"))) }`
   - Auth: None required
   - Filter: `isDeleted === false` AND `status === "published"`, then optionally by category
   - Returns: Array sorted by publishedAt descending

3. `getBySlug` - Public query (no auth). Returns single published, non-deleted blog post by slug. Returns null if not found, deleted, or draft.
   - Args: `{ slug: v.string() }`
   - Uses: `withIndex("by_slug", (q) => q.eq("slug", args.slug))`
   - Filter: Returns null if `isDeleted === true` or `status !== "published"` (for public access)
   - Returns: Post with `coverImageUrl` and `readingTime` added, or null

4. `getById` - Admin query (authenticated). Returns single blog post by ID regardless of status. Used for editing in admin.
   - Args: `{ id: v.id("blogPosts") }`
   - Auth: Required
   - Returns: Post with `coverImageUrl` and `readingTime` added, or null

**Mutations to implement:**

5. `create` - Creates new draft blog post with auto-generated slug.
   - Args: `{ title: v.string(), excerpt: v.string(), content: v.string(), category: v.union(...categories), coverImageId: v.optional(v.id("_storage")), coverImageAlt: v.optional(v.string()), slug: v.optional(v.string()) }`
   - Auth: Required
   - Slug generation: Use `slugify(title, { lower: true, strict: true })` unless `args.slug` provided. Check uniqueness via `by_slug` index. If collision, append `-2`, `-3`, etc. in a while loop. Include deleted posts in slug check (prevent SEO confusion from slug reuse).
   - DisplayOrder: Query all posts, find max displayOrder, add 1.
   - Sets: `status: "draft"`, `isDeleted: false`, `createdAt: Date.now()`, `authorId: userId`
   - Returns: new post ID

6. `update` - Updates existing blog post fields.
   - Args: `{ id: v.id("blogPosts"), title: v.optional(v.string()), excerpt: v.optional(v.string()), content: v.optional(v.string()), category: v.optional(v.union(...categories)), coverImageId: v.optional(v.id("_storage")), coverImageAlt: v.optional(v.string()), slug: v.optional(v.string()) }`
   - Auth: Required
   - CRITICAL: If the post is published (`existing.status === "published"`) and `args.slug` is provided and differs from `existing.slug`, throw `new Error("Cannot change slug after publishing")`.
   - If slug is being changed (and post is draft), run uniqueness check same as create.
   - Uses `ctx.db.patch(id, updates)` -- only patch provided fields (same pattern as projects.ts update).
   - Returns: true

7. `publish` - Transitions post from draft to published.
   - Args: `{ id: v.id("blogPosts") }`
   - Auth: Required
   - Validation before publishing:
     - Post must exist and not be deleted
     - `coverImageId` must be set (not undefined/null) -- throw "Cover image required for publishing"
     - `coverImageAlt` must be set and non-empty -- throw "Cover image alt text required for publishing"
     - `content` must be at least 100 characters -- throw "Content too short for publishing"
   - Sets: `status: "published"`, `publishedAt: Date.now()` ONLY if publishedAt is not already set (preserves original publish date on re-publish)
   - Returns: true

8. `unpublish` - Transitions post back to draft. Does NOT clear publishedAt.
   - Args: `{ id: v.id("blogPosts") }`
   - Auth: Required
   - Sets: `status: "draft"` only. Does NOT touch publishedAt.
   - Returns: true

9. `remove` - Soft deletes a blog post.
   - Args: `{ id: v.id("blogPosts") }`
   - Auth: Required
   - Sets: `isDeleted: true`
   - Does NOT delete the storage file (cover image preserved for restore).
   - Returns: true

10. `restore` - Restores a soft-deleted blog post.
    - Args: `{ id: v.id("blogPosts") }`
    - Auth: Required
    - Sets: `isDeleted: false`
    - Returns: true

11. `reorder` - Reorders blog posts by setting displayOrder based on array position.
    - Args: `{ postIds: v.array(v.id("blogPosts")) }`
    - Auth: Required
    - Pattern: `Promise.all(args.postIds.map((id, index) => ctx.db.patch(id, { displayOrder: index + 1 })))`
    - Returns: true

12. `generateUploadUrl` - Generates a Convex storage upload URL for cover images.
    - Args: `{}`
    - Auth: Required
    - Returns: `await ctx.storage.generateUploadUrl()`

**Important implementation notes:**
- Follow `convex/projects.ts` import style and function structure exactly.
- Every mutation starts with `const userId = await getAuthUserId(ctx); if (!userId) throw new Error("Unauthorized");`
- Resolve `coverImageUrl` in queries using `post.coverImageId ? await ctx.storage.getUrl(post.coverImageId) : null` (coverImageId is optional for drafts).
- The `list` query for admin shows ALL non-deleted posts (drafts + published). The `listPublished` query is for public pages.
- Reading time is computed in every query that returns post data, not stored in the database.
  </action>
  <verify>
Run `bun run type-check` to confirm no TypeScript errors. Run `bun run lint` to confirm no lint issues. Verify the file exports all 12 functions listed above by checking the exports.
  </verify>
  <done>
convex/blogPosts.ts exists with all 12 exported functions. Type-check passes. Slug generation uses slugify with collision resolution. Publishing validates cover image + alt text + content length. Soft delete pattern with restore. Reading time computed in queries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create case studies Convex module</name>
  <files>convex/caseStudies.ts</files>
  <action>
Create `convex/caseStudies.ts` following the exact patterns from `convex/projects.ts` and the blog posts module from Task 1.

**Imports:**
```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { getAuthUserId } from "./auth";
import slugify from "slugify";
```

**Queries to implement:**

1. `list` - Admin query (authenticated). Returns all non-deleted case studies. Sort by displayOrder ASC with _creationTime as tiebreaker.
   - Args: `{ status: v.optional(v.union(v.literal("draft"), v.literal("published"))) }`
   - Auth: Required
   - Filter: `isDeleted === false`, optionally by status
   - Resolves: coverImageUrl, linked project name (if projectId exists and project is not deleted)
   - Returns: Array with `coverImageUrl` and `project` (or null) fields added

2. `listPublished` - Public query (no auth). Returns only published, non-deleted case studies.
   - Args: `{}`
   - Auth: None required
   - Filter: `isDeleted === false` AND `status === "published"`
   - Resolves: coverImageUrl, linked project (safe lookup -- null if project deleted)
   - Sort: by displayOrder ASC
   - Returns: Array with project data embedded

3. `getBySlug` - Public query (no auth). Returns single published, non-deleted case study by slug.
   - Args: `{ slug: v.string() }`
   - Uses: `withIndex("by_slug", (q) => q.eq("slug", args.slug))`
   - Filter: Returns null if `isDeleted === true` or `status !== "published"`
   - Resolves: coverImageUrl, linked project (safe: `const project = caseStudy.projectId ? await ctx.db.get(caseStudy.projectId) : null;` then check project is not null and not deleted)
   - Returns: Case study with project and coverImageUrl, or null

4. `getByProject` - Public query (no auth). Returns all published case studies for a given project.
   - Args: `{ projectId: v.id("projects") }`
   - Uses: `withIndex("by_project", (q) => q.eq("projectId", args.projectId))`
   - Filter: `isDeleted === false` AND `status === "published"`
   - Resolves: coverImageUrl
   - Returns: Array sorted by displayOrder ASC

5. `getById` - Admin query (authenticated). Returns single case study by ID regardless of status.
   - Args: `{ id: v.id("caseStudies") }`
   - Auth: Required
   - Resolves: coverImageUrl, linked project
   - Returns: Case study with resolved fields, or null

**Mutations to implement:**

6. `create` - Creates new draft case study with auto-generated slug.
   - Args: `{ title: v.string(), projectId: v.optional(v.id("projects")), problemHeading: v.string(), problemContent: v.string(), solutionHeading: v.string(), solutionContent: v.string(), resultsHeading: v.string(), resultsContent: v.string(), metrics: v.array(v.object({ label: v.string(), value: v.string() })), coverImageId: v.optional(v.id("_storage")), coverImageAlt: v.optional(v.string()), slug: v.optional(v.string()) }`
   - Auth: Required
   - Slug generation: Same pattern as blogPosts (slugify + uniqueness check against caseStudies table by_slug index, includes deleted in check)
   - DisplayOrder: Query all case studies, find max, add 1.
   - Sets: `status: "draft"`, `isDeleted: false`, `createdAt: Date.now()`, `authorId: userId`
   - Default headings if empty: The admin UI will provide defaults, but the mutation accepts whatever strings are passed.
   - Returns: new case study ID

7. `update` - Updates existing case study fields.
   - Args: All fields from create as optional (except id which is required as `v.id("caseStudies")`)
   - Auth: Required
   - CRITICAL: Same slug lock rule as blog posts -- if published and slug changes, throw error.
   - If slug changes on draft, run uniqueness check.
   - Uses `ctx.db.patch(id, updates)` pattern.
   - Returns: true

8. `publish` - Transitions case study from draft to published.
   - Args: `{ id: v.id("caseStudies") }`
   - Auth: Required
   - Validation:
     - Must exist and not be deleted
     - `coverImageId` must be set -- throw "Cover image required for publishing"
     - `coverImageAlt` must be set and non-empty -- throw "Cover image alt text required for publishing"
     - `metrics` array must have at least 1 entry -- throw "At least one metric required for publishing"
   - Sets: `status: "published"`, `publishedAt: Date.now()` only if not already set
   - Returns: true

9. `unpublish` - Transitions back to draft. Does NOT clear publishedAt.
   - Args: `{ id: v.id("caseStudies") }`
   - Auth: Required
   - Returns: true

10. `remove` - Soft deletes a case study.
    - Args: `{ id: v.id("caseStudies") }`
    - Auth: Required
    - Sets: `isDeleted: true`
    - Returns: true

11. `restore` - Restores a soft-deleted case study.
    - Args: `{ id: v.id("caseStudies") }`
    - Auth: Required
    - Sets: `isDeleted: false`
    - Returns: true

12. `reorder` - Reorders case studies by setting displayOrder.
    - Args: `{ caseStudyIds: v.array(v.id("caseStudies")) }`
    - Auth: Required
    - Same pattern as blogPosts reorder.
    - Returns: true

13. `generateUploadUrl` - Generates Convex storage upload URL.
    - Args: `{}`
    - Auth: Required
    - Returns: upload URL

**Important implementation notes:**
- When resolving project references in queries, ALWAYS handle null gracefully: `const project = caseStudy.projectId ? await ctx.db.get(caseStudy.projectId) : null;` and then filter deleted projects: `const validProject = project && !(project as any).isDeleted ? project : null;` (Note: projects table does not have isDeleted field currently, so just null-check the project. If it was hard-deleted via the existing projects.remove mutation, ctx.db.get returns null.)
- The safe project lookup is: `const project = caseStudy.projectId ? await ctx.db.get(caseStudy.projectId) : null;` -- if project was deleted (hard delete in existing projects.ts), this returns null. Return `project: project ? { _id: project._id, name: project.name, slug: project.slug } : null` to avoid leaking full project data.
- No reading time calculation for case studies (only blog posts per research).
- Metrics validation on publish: at least 1 metric required.
  </action>
  <verify>
Run `bun run type-check` to confirm no TypeScript errors. Run `bun run lint` to confirm no lint issues. Verify the file exports all 13 functions listed above.
  </verify>
  <done>
convex/caseStudies.ts exists with all 13 exported functions. Type-check passes. Project linking resolves safely (null if project deleted). Slug generation uses slugify with collision resolution. Publishing validates cover image + alt text + at least 1 metric. Soft delete with restore.
  </done>
</task>

</tasks>

<verification>
1. `bun run type-check` passes with no errors across all convex files
2. `bun run lint` passes with no errors
3. convex/blogPosts.ts exports: list, listPublished, getBySlug, getById, create, update, publish, unpublish, remove, restore, reorder, generateUploadUrl
4. convex/caseStudies.ts exports: list, listPublished, getBySlug, getByProject, getById, create, update, publish, unpublish, remove, restore, reorder, generateUploadUrl
5. All mutations check auth via getAuthUserId
6. All public queries filter isDeleted === false and status === "published"
7. Slug generation handles collisions with numeric suffixes
8. Published slug immutability enforced in update mutations
9. Publish mutations validate required fields (cover image, alt text, content length / metrics count)
10. Soft delete preserves storage files and allows restore
</verification>

<success_criteria>
- Both modules follow the exact patterns from convex/projects.ts (import style, function structure, auth checks)
- Blog posts: create with slug gen, update with slug lock, publish with validation, soft delete, reading time in queries
- Case studies: create with project link, update with slug lock, publish with metric validation, safe project resolution
- Phase 16 (admin UI) can import and call all mutations without modification
- Phase 17 (public pages) can import and call listPublished and getBySlug without modification
</success_criteria>

<output>
After completion, create `.planning/phases/15-content-schema-backend/15-02-SUMMARY.md`
</output>
