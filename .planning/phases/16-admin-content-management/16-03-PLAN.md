---
phase: 16-admin-content-management
plan: 03
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - components/admin/case-study-form.tsx
  - components/admin/sortable-case-study-list.tsx
  - components/admin/sortable-case-study-row.tsx
  - app/admin/case-studies/page.tsx
  - app/admin/case-studies/new/page.tsx
  - app/admin/case-studies/[id]/edit/page.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can view list of case studies with status filter tabs (All/Draft/Published)"
    - "Admin can see linked project name per case study row (or 'Unlinked')"
    - "Admin can drag-to-reorder case studies in the list"
    - "Admin can create a new case study with a single markdown editor containing all three sections"
    - "Admin can customize section headings via input fields above the editor"
    - "Admin can edit an existing case study with pre-populated form fields"
    - "Admin can delete a case study with confirmation dialog"
    - "Admin can upload a cover image for case studies"
    - "Admin can add/remove metrics (label + value pairs)"
  artifacts:
    - path: "components/admin/case-study-form.tsx"
      provides: "Case study form with single MarkdownEditor, 3 heading inputs, metrics, image upload, section parsing helpers"
      min_lines: 150
    - path: "components/admin/sortable-case-study-list.tsx"
      provides: "Drag-to-reorder case study table using dnd-kit"
      min_lines: 30
    - path: "components/admin/sortable-case-study-row.tsx"
      provides: "Individual sortable case study row with project link and actions"
      min_lines: 40
    - path: "app/admin/case-studies/page.tsx"
      provides: "Case study list page with filter tabs, sortable list, delete confirmation"
      min_lines: 50
    - path: "app/admin/case-studies/new/page.tsx"
      provides: "Create new case study page"
      min_lines: 20
    - path: "app/admin/case-studies/[id]/edit/page.tsx"
      provides: "Edit case study page with pre-loaded data"
      min_lines: 30
  key_links:
    - from: "app/admin/case-studies/page.tsx"
      to: "convex/caseStudies.ts"
      via: "useQuery(api.caseStudies.list) and useMutation(api.caseStudies.reorder/remove)"
      pattern: "api\\.caseStudies\\.(list|reorder|remove)"
    - from: "components/admin/case-study-form.tsx"
      to: "components/admin/markdown-editor.tsx"
      via: "Single MarkdownEditor component for combined section content"
      pattern: "MarkdownEditor"
    - from: "components/admin/case-study-form.tsx"
      to: "components/admin/image-upload-zone.tsx"
      via: "ImageUploadZone with case study generateUploadUrl"
      pattern: "ImageUploadZone"
    - from: "app/admin/case-studies/new/page.tsx"
      to: "convex/caseStudies.ts"
      via: "useMutation(api.caseStudies.create)"
      pattern: "api\\.caseStudies\\.create"
    - from: "app/admin/case-studies/[id]/edit/page.tsx"
      to: "convex/caseStudies.ts"
      via: "useQuery(api.caseStudies.getById) and useMutation(api.caseStudies.update)"
      pattern: "api\\.caseStudies\\.(getById|update)"
---

<objective>
Build the complete case study admin interface: sortable list page with status filter tabs showing linked project names, case study form component with a SINGLE markdown editor (user decision: not separate editors per section), section heading inputs, metrics management, and image upload, plus route pages for creating and editing case studies.

Purpose: Addresses CASE-04 (edit/delete case studies) and CASE-05 (drag-to-reorder). Follows blog admin pattern established in Plan 02 for consistency. The form bridges between the single-editor UX (user decision) and the backend's 6 separate section fields.
Output: 6 new files creating the full case study CRUD admin experience.
</objective>

<execution_context>
@C:\Users\jonge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jonge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-admin-content-management/16-CONTEXT.md
@.planning/phases/16-admin-content-management/16-RESEARCH.md
@.planning/phases/16-admin-content-management/16-01-SUMMARY.md

@components/admin/sortable-project-list.tsx
@components/admin/sortable-project-row.tsx
@components/admin/project-form.tsx
@components/admin/confirm-dialog.tsx
@components/admin/image-upload-zone.tsx
@components/admin/markdown-editor.tsx
@app/admin/projects/page.tsx
@app/admin/projects/new/page.tsx
@app/admin/projects/[id]/edit/page.tsx
@convex/caseStudies.ts
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create case study list page with sortable table and filter tabs</name>
  <files>
    components/admin/sortable-case-study-list.tsx
    components/admin/sortable-case-study-row.tsx
    app/admin/case-studies/page.tsx
  </files>
  <action>
    Replicate the blog list pattern (Plan 02 Task 1) for case studies with these differences.

    **A. Create `components/admin/sortable-case-study-row.tsx`:**

    Follow `sortable-blog-row.tsx` / `sortable-project-row.tsx` pattern. Differences:
    - "use client" directive
    - Export interface `CaseStudy`:
      ```typescript
      export interface CaseStudy {
        _id: Id<"caseStudies">;
        title: string;
        status: "draft" | "published";
        project: { _id: Id<"projects">; name: string; slug: string } | null;
        coverImageUrl: string | null;
        createdAt: number;
      }
      ```
    - Props: `caseStudy: CaseStudy`, `onDelete: () => void`
    - Table row columns:
      1. Drag handle (GripVertical icon)
      2. Title (font-medium)
      3. Project (show `caseStudy.project?.name` or "Unlinked" in muted text) - per user decision
      4. Status (Badge - `default` for published, `outline` for draft)
      5. Date (format createdAt)
      6. Actions: Edit (Link to `/admin/case-studies/${caseStudy._id}/edit`) + Delete (triggers onDelete)
    - ConfirmDialog for delete: `Are you sure you want to delete "${caseStudy.title}"? This action cannot be undone.`

    **B. Create `components/admin/sortable-case-study-list.tsx`:**

    Follow `sortable-blog-list.tsx` / `sortable-project-list.tsx` pattern:
    - "use client" directive
    - Import CaseStudy and SortableCaseStudyRow
    - Props: `caseStudies: CaseStudy[]`, `onReorder: (reordered: CaseStudy[]) => void`, `onDelete: (cs: CaseStudy) => void`
    - Same DndContext + SortableContext setup
    - Table headers: (drag handle), Title, Project, Status, Date, Actions

    **C. Create `app/admin/case-studies/page.tsx`:**

    Follow `app/admin/blog/page.tsx` pattern (from Plan 02):
    - "use client" directive
    - useQuery: `api.caseStudies.list` (returns non-deleted case studies with image URLs and project data)
    - useMutation: `api.caseStudies.reorder` and `api.caseStudies.remove`
    - Filter tabs: All / Draft / Published (same pattern as blog)
    - Global ordering (same as blog - filter for display, reorder globally)
    - handleReorder: `reorder({ caseStudyIds: reorderedStudies.map(cs => cs._id) })` with toast
    - handleDeleteConfirm: `remove({ id: deleteTarget._id })` with toast
    - Empty state: Card with "No case studies yet. Create your first case study!" + link to /admin/case-studies/new
    - Header: "Case Studies" h1 + "New Case Study" button (Plus icon, links to /admin/case-studies/new)
    - ConfirmDialog for delete at bottom
    - Loading state when data === undefined

    IMPORTANT: The `reorder` mutation in caseStudies.ts takes `{ caseStudyIds: v.array(v.id("caseStudies")) }`. Use the correct field name.
  </action>
  <verify>
    - `bun run type-check` passes
    - `bun run lint` passes
    - All 3 files exist with correct imports
    - Case study rows show linked project name or "Unlinked"
    - Filter tabs work for All/Draft/Published
  </verify>
  <done>Case study list page renders with filter tabs, linked project names, drag-to-reorder table, and delete confirmation dialog</done>
</task>

<task type="auto">
  <name>Task 2: Create case study form component (single editor) and route pages</name>
  <files>
    components/admin/case-study-form.tsx
    app/admin/case-studies/new/page.tsx
    app/admin/case-studies/[id]/edit/page.tsx
  </files>
  <action>
    **CRITICAL USER DECISION:** Case studies use a SINGLE markdown editor with section dividers (headings), NOT separate editors per section. The backend schema has 6 separate fields (problemHeading/Content, solutionHeading/Content, resultsHeading/Content) which are FIXED. The form must bridge between the single-editor UX and the multi-field backend.

    **A. Create `components/admin/case-study-form.tsx`:**

    - "use client" directive
    - Imports: react-hook-form, zodResolver, zod, MarkdownEditor, ImageUploadZone, Form components, Input, Select, Button, useMutation, useQuery, api, Trash2 icon, Plus icon

    **Helper functions (define above the component, exported for testability):**

    1. `combineSections` - Assembles 3 sections into a single markdown string for the editor:
       ```typescript
       export function combineSections(
         headings: { problem: string; solution: string; results: string },
         contents: { problem: string; solution: string; results: string }
       ): string {
         const sections: string[] = [];
         sections.push(`## ${headings.problem}\n\n${contents.problem}`);
         sections.push(`## ${headings.solution}\n\n${contents.solution}`);
         sections.push(`## ${headings.results}\n\n${contents.results}`);
         return sections.join("\n\n");
       }
       ```

    2. `parseSections` - Splits the combined markdown string back into 3 content parts using the heading values as delimiters:
       ```typescript
       export function parseSections(
         combinedContent: string,
         headings: { problem: string; solution: string; results: string }
       ): { problemContent: string; solutionContent: string; resultsContent: string } {
         // Build regex pattern that splits on ## followed by any of the three headings
         // Use the actual heading values as delimiters (they come from the input fields)
         const escapeRegex = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
         const pattern = new RegExp(
           `^##\\s+(?:${escapeRegex(headings.problem)}|${escapeRegex(headings.solution)}|${escapeRegex(headings.results)})\\s*$`,
           "m"
         );

         // Split the content by heading markers
         const parts = combinedContent.split(pattern);

         // parts[0] is content before first heading (should be empty or whitespace)
         // parts[1] is problem content, parts[2] is solution content, parts[3] is results content
         // Trim each part
         return {
           problemContent: (parts[1] ?? "").trim(),
           solutionContent: (parts[2] ?? "").trim(),
           resultsContent: (parts[3] ?? "").trim(),
         };
       }
       ```

       **Important edge case handling:** The split approach above is simple but fragile if headings appear in content. A more robust approach: find the INDEX of each heading line, then extract content between them:
       ```typescript
       export function parseSections(
         combinedContent: string,
         headings: { problem: string; solution: string; results: string }
       ): { problemContent: string; solutionContent: string; resultsContent: string } {
         const lines = combinedContent.split("\n");

         // Find line indices where each heading appears as ## Heading
         const findHeadingIndex = (heading: string, startFrom = 0): number => {
           for (let i = startFrom; i < lines.length; i++) {
             if (lines[i].trim() === `## ${heading}`) return i;
           }
           return -1;
         };

         const problemIdx = findHeadingIndex(headings.problem);
         const solutionIdx = findHeadingIndex(headings.solution, problemIdx + 1);
         const resultsIdx = findHeadingIndex(headings.results, solutionIdx + 1);

         // Extract content between headings (skip the heading line itself)
         const extractBetween = (startIdx: number, endIdx: number): string => {
           if (startIdx === -1) return "";
           const end = endIdx === -1 ? lines.length : endIdx;
           return lines.slice(startIdx + 1, end).join("\n").trim();
         };

         return {
           problemContent: extractBetween(problemIdx, solutionIdx),
           solutionContent: extractBetween(solutionIdx, resultsIdx),
           resultsContent: extractBetween(resultsIdx, -1),
         };
       }
       ```
       **USE THE SECOND (index-based) APPROACH.** It handles edge cases better.

    **Zod schema `caseStudyFormSchema`:**
      - title: z.string().min(1, "Title is required")
      - slug: z.string().optional()
      - projectId: z.string().optional()
      - problemHeading: z.string().min(1, "Problem heading is required") (default: "The Challenge")
      - solutionHeading: z.string().min(1, "Solution heading is required") (default: "Our Approach")
      - resultsHeading: z.string().min(1, "Results heading is required") (default: "The Results")
      - combinedContent: z.string().min(1, "Content is required") -- THIS IS THE SINGLE CONTENT FIELD
      - metrics: z.array(z.object({ label: z.string().min(1), value: z.string().min(1) }))
      - coverImageId: z.string().optional()
      - coverImageAlt: z.string().optional()
      - `.refine()` for conditional alt text validation (same as blog form)

    **NOTE:** The schema validates `combinedContent` (the single editor content), NOT separate problemContent/solutionContent/resultsContent. The parsing into separate fields happens at submit time.

    - Export interface `CaseStudyFormData`:
      ```typescript
      export interface CaseStudyFormData {
        title: string;
        slug?: string;
        projectId?: string;
        problemHeading: string;
        problemContent: string;
        solutionHeading: string;
        solutionContent: string;
        resultsHeading: string;
        resultsContent: string;
        metrics: Array<{ label: string; value: string }>;
        coverImageId?: string;
        coverImageAlt?: string;
      }
      ```
      This interface matches what the backend expects (6 separate fields). The form internally uses `combinedContent` but transforms it to this shape on submit.

    - Props:
      ```typescript
      interface CaseStudyFormProps {
        mode: "create" | "edit";
        initialData?: {
          title: string;
          slug: string;
          projectId?: string;
          problemHeading: string;
          problemContent: string;
          solutionHeading: string;
          solutionContent: string;
          resultsHeading: string;
          resultsContent: string;
          metrics: Array<{ label: string; value: string }>;
          coverImageId?: string;
          coverImageAlt?: string;
          coverImageUrl?: string | null;
          status?: "draft" | "published";
        };
        onSubmit: (data: CaseStudyFormData) => Promise<void>;
        onCancel: () => void;
      }
      ```

    - **Initializing form defaults:**
      When `initialData` is provided (edit mode), compute the initial `combinedContent`:
      ```typescript
      const initialCombinedContent = initialData
        ? combineSections(
            { problem: initialData.problemHeading, solution: initialData.solutionHeading, results: initialData.resultsHeading },
            { problem: initialData.problemContent, solution: initialData.solutionContent, results: initialData.resultsContent }
          )
        : combineSections(
            { problem: "The Challenge", solution: "Our Approach", results: "The Results" },
            { problem: "", solution: "", results: "" }
          );
      ```
      Use this as the default value for the `combinedContent` field in useForm.

    - **On create mode (no initialData):** Pre-populate the editor with skeleton headings so the user sees the structure immediately:
      ```
      ## The Challenge

      (describe the problem here)

      ## Our Approach

      (describe the solution here)

      ## The Results

      (describe the outcomes here)
      ```
      This gives the user a clear template. The placeholder text in parentheses is meant to be replaced.

    - **Heading input sync:** When a user changes a heading input (e.g., changes "The Challenge" to "The Problem"), update the corresponding `## Heading` line in the combined content:
      - Watch the heading fields with `form.watch`
      - Use a `useEffect` or callback on heading blur/change to find the old heading line in combinedContent and replace it
      - This keeps the editor content in sync with heading inputs
      - Implementation: on heading field blur, get current combinedContent, find the line matching `## ${previousHeading}`, replace with `## ${newHeading}`, and update combinedContent via `form.setValue("combinedContent", updatedContent)`
      - Store previous heading values in a ref to detect changes

    - **Form layout (vertical flow):**
      1. **Title** - Input, required
      2. **Slug** - Input. Same logic as blog: disabled on create (placeholder "Auto-generated on save"), enabled on edit for drafts, disabled for published
      3. **Linked Project** - Select dropdown populated from `useQuery(api.projects.list)`. Options: "None (standalone)" + all projects. Show project names as options.
      4. **Cover Image** - ImageUploadZone with caseStudies.generateUploadUrl (same pattern as blog)
      5. **Cover Image Alt Text** - Input with description "Required when cover image is present"
      6. **Section Headings** - Three input fields in a row (grid grid-cols-3 gap-4), labeled "Problem Heading", "Solution Heading", "Results Heading" with defaults "The Challenge", "Our Approach", "The Results". These are regular form fields bound to problemHeading/solutionHeading/resultsHeading.
      7. **Content** - SINGLE MarkdownEditor (height 600, taller since it holds all 3 sections). Bound to `combinedContent` form field. The editor shows the full document with `## Heading` dividers between sections.
      8. **Metrics** - Dynamic field array:
         - Each metric has a Label input and Value input side by side
         - "Add Metric" button (Plus icon) appends new row
         - Each row has a Remove button (Trash2 icon)
         - Minimum 0 metrics for drafts (publish mutation requires at least 1)
         - Manage with form.watch + form.setValue:
           ```typescript
           const metrics = form.watch("metrics");
           const addMetric = () => form.setValue("metrics", [...metrics, { label: "", value: "" }]);
           const removeMetric = (index: number) => form.setValue("metrics", metrics.filter((_, i) => i !== index));
           ```

    - **Submit handler transformation:**
      When the form is submitted, transform the form values to the CaseStudyFormData shape:
      ```typescript
      const handleFormSubmit = (values: z.infer<typeof caseStudyFormSchema>) => {
        const headings = {
          problem: values.problemHeading,
          solution: values.solutionHeading,
          results: values.resultsHeading,
        };
        const parsed = parseSections(values.combinedContent, headings);

        const data: CaseStudyFormData = {
          title: values.title,
          slug: values.slug,
          projectId: values.projectId,
          problemHeading: values.problemHeading,
          problemContent: parsed.problemContent,
          solutionHeading: values.solutionHeading,
          solutionContent: parsed.solutionContent,
          resultsHeading: values.resultsHeading,
          resultsContent: parsed.resultsContent,
          metrics: values.metrics,
          coverImageId: values.coverImageId,
          coverImageAlt: values.coverImageAlt,
        };
        return onSubmit(data);
      };
      ```

    - Form actions: same as blog (Create Draft / Save Changes + Cancel)

    **B. Create `app/admin/case-studies/new/page.tsx`:**

    Follow `app/admin/blog/new/page.tsx` pattern:
    - "use client" directive
    - useMutation(api.caseStudies.create)
    - handleSubmit: call create with form data. Cast projectId: `data.projectId ? data.projectId as Id<"projects"> : undefined`. Cast coverImageId: `data.coverImageId ? data.coverImageId as Id<"_storage"> : undefined`. Do NOT pass slug (server auto-generates). Pass all 6 section fields (problemHeading, problemContent, solutionHeading, solutionContent, resultsHeading, resultsContent) as separate arguments to the mutation.
    - Toast + router.push("/admin/case-studies") on success
    - Render: max-w-3xl container, h1 "New Case Study", CaseStudyForm mode="create"

    **C. Create `app/admin/case-studies/[id]/edit/page.tsx`:**

    Follow `app/admin/blog/[id]/edit/page.tsx` pattern:
    - "use client" directive
    - useQuery(api.caseStudies.getById, { id: caseStudyId }) - cast params.id as Id<"caseStudies">
    - useMutation(api.caseStudies.update)
    - handleSubmit: call update with { id: caseStudyId, ...data }. Cast projectId and coverImageId appropriately. Pass all 6 section fields separately.
    - Loading/Not found states
    - Toast + router.push("/admin/case-studies") on success
    - Render: max-w-3xl container, h1 "Edit Case Study", CaseStudyForm mode="edit" with initialData

    Note on initial data mapping: The getById query returns the full case study object with all 6 section fields. Pass them directly to initialData. The form's `combineSections` helper merges them into the single editor on init.

    Note on the create mutation args: caseStudies.create takes `{ title, projectId?, problemHeading, problemContent, solutionHeading, solutionContent, resultsHeading, resultsContent, metrics, coverImageId?, coverImageAlt?, slug? }`. All section headings and contents are required strings.
  </action>
  <verify>
    - `bun run type-check` passes
    - `bun run lint` passes
    - All 3 files exist
    - CaseStudyForm has exactly ONE MarkdownEditor instance (not 3)
    - CaseStudyForm has 3 heading input fields above the editor
    - The `combineSections` and `parseSections` helper functions exist in case-study-form.tsx
    - On submit, form data is transformed from single combinedContent to 6 separate section fields
    - CaseStudyForm has dynamic metrics array management
    - CaseStudyForm has project linking dropdown populated from useQuery
    - New page creates case study passing 6 separate section fields to mutation
    - Edit page loads case study data and combines sections into single editor
    - Zod schema validates combinedContent (single field), not 3 separate content fields
  </verify>
  <done>
    Case study form renders with a SINGLE markdown editor containing all three sections separated by ## headings. Three heading input fields above the editor control section names. On save, the combined content is parsed back into 6 separate fields for the backend. New case study page creates drafts. Edit page loads existing data, combines sections into the editor, and saves back as separate fields.
  </done>
</task>

</tasks>

<verification>
1. `bun run type-check` - all TypeScript checks pass across all 6 new files
2. `bun run lint` - no ESLint errors
3. `bun run build` - production build succeeds
4. Case study list at /admin/case-studies renders filter tabs and sortable table
5. Case study rows show linked project name or "Unlinked"
6. Case study form has exactly ONE MarkdownEditor with all sections in a single document
7. Three heading inputs above the editor control section names
8. On create, editor is pre-populated with heading template structure
9. On edit, the 6 backend fields are combined into a single editor document
10. On save, parseSections splits the single document back into 6 fields for the mutation
11. Metrics can be added and removed dynamically
12. Project linking dropdown shows available projects from database
13. Delete confirmation dialog works correctly
14. Drag-to-reorder calls caseStudies.reorder with correct args (caseStudyIds field name)
</verification>

<success_criteria>
- Admin can navigate to /admin/case-studies and see list of case studies
- Admin can filter case studies by All/Draft/Published status tabs
- Admin can see linked project name per row (or "Unlinked")
- Admin can drag-to-reorder case studies and order persists
- Admin can click "New Case Study" and see a single editor with section heading template
- Admin can customize section headings via 3 input fields above the editor
- Admin can write all content in one editor with ## heading dividers between sections
- Admin can edit existing case studies with sections combined into single editor view
- Admin can add/remove metrics (label + value pairs)
- Admin can link case study to existing project via dropdown
- Admin can delete case studies with confirmation dialog
- Cover image upload works with case study storage endpoint
- All patterns match blog admin and projects admin for consistency
</success_criteria>

<output>
After completion, create `.planning/phases/16-admin-content-management/16-03-SUMMARY.md`
</output>
