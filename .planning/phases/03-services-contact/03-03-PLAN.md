---
phase: 03-services-contact
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - components/calendly/calendly-button.tsx
  - components/forms/contact-form.tsx
  - components/forms/honeypot-field.tsx
autonomous: true

must_haves:
  truths:
    - "Calendly popup opens when booking button clicked"
    - "Contact form validates input before submission"
    - "Honeypot field hidden from users but present in DOM"
  artifacts:
    - path: "components/calendly/calendly-button.tsx"
      provides: "Calendly popup button component"
      min_lines: 20
    - path: "components/forms/contact-form.tsx"
      provides: "Contact form with validation"
      min_lines: 80
    - path: "components/forms/honeypot-field.tsx"
      provides: "Hidden spam protection field"
      min_lines: 15
  key_links:
    - from: "components/calendly/calendly-button.tsx"
      to: "react-calendly"
      via: "dynamic import"
      pattern: "dynamic.*react-calendly"
    - from: "components/forms/contact-form.tsx"
      to: "lib/validations/contact-schema.ts"
      via: "import"
      pattern: "import.*contactSchema"
    - from: "components/forms/contact-form.tsx"
      to: "convex/contacts.ts"
      via: "useMutation"
      pattern: "useMutation.*api.contacts"
---

<objective>
Create Calendly popup button component and contact form with React Hook Form validation.

Purpose: Reusable booking button and validated contact form for conversion pages.
Output: CalendlyButton for booking CTAs, ContactForm with honeypot spam protection.
</objective>

<execution_context>
@C:\Users\jonge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jonge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-services-contact/03-CONTEXT.md
@.planning/phases/03-services-contact/03-RESEARCH.md
@.planning/phases/03-services-contact/03-01-SUMMARY.md
@lib/validations/contact-schema.ts
@components/ui/form.tsx
@components/ui/button.tsx
@components/ui/input.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Calendly button component</name>
  <files>components/calendly/calendly-button.tsx</files>
  <action>
Create components/calendly/ directory and calendly-button.tsx:

```typescript
"use client";

import dynamic from "next/dynamic";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

// Dynamic import with SSR disabled - prevents hydration errors
// Calendly widget requires browser DOM APIs
const PopupButton = dynamic(
  () => import("react-calendly").then((mod) => mod.PopupButton),
  { ssr: false }
);

interface CalendlyButtonProps {
  url: string;
  text?: string;
  variant?: "default" | "outline" | "ghost";
  className?: string;
  size?: "default" | "sm" | "lg";
}

export function CalendlyButton({
  url,
  text = "Book a Call",
  variant = "default",
  className,
  size = "default",
}: CalendlyButtonProps) {
  // Define button classes based on variant and size to match shadcn Button
  const buttonClasses = cn(
    "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors",
    "focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring",
    "disabled:pointer-events-none disabled:opacity-50",
    {
      // Variants
      "bg-primary text-primary-foreground shadow hover:bg-primary/90": variant === "default",
      "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground": variant === "outline",
      "hover:bg-accent hover:text-accent-foreground": variant === "ghost",
      // Sizes
      "h-9 px-4 py-2": size === "default",
      "h-8 rounded-md px-3 text-xs": size === "sm",
      "h-10 rounded-md px-8": size === "lg",
    },
    className
  );

  return (
    <PopupButton
      url={url}
      rootElement={typeof document !== "undefined" ? document.body : undefined}
      text={text}
      className={buttonClasses}
    />
  );
}
```

Key patterns:
- Dynamic import with ssr: false prevents Next.js hydration errors
- Calendly's PopupButton opens modal overlay (keeps user in context)
- Styled to match shadcn Button appearance
- rootElement uses document.body (safer than __next which may not exist)
- typeof document check for SSR safety in className computation
  </action>
  <verify>
    - `bun run type-check` passes
    - File exports CalendlyButton component
  </verify>
  <done>
    - CalendlyButton opens popup modal when clicked
    - Styled consistently with shadcn Button variants
    - SSR-safe with dynamic import
  </done>
</task>

<task type="auto">
  <name>Task 2: Create honeypot field component</name>
  <files>components/forms/honeypot-field.tsx</files>
  <action>
Create components/forms/ directory and honeypot-field.tsx:

```typescript
import { FormField, FormItem, FormControl } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import type { Control } from "react-hook-form";
import type { ContactFormData } from "@/lib/validations/contact-schema";

interface HoneypotFieldProps {
  control: Control<ContactFormData>;
}

export function HoneypotField({ control }: HoneypotFieldProps) {
  return (
    <FormField
      control={control}
      name="honeypot"
      render={({ field }) => (
        <FormItem
          className="absolute -left-[9999px] -top-[9999px]"
          aria-hidden="true"
        >
          <FormControl>
            <Input
              {...field}
              type="text"
              tabIndex={-1}
              autoComplete="off"
              placeholder="Leave this field empty"
            />
          </FormControl>
        </FormItem>
      )}
    />
  );
}
```

Key patterns:
- Positioned off-screen (not display:none - some bots detect that)
- aria-hidden="true" hides from screen readers
- tabIndex={-1} prevents keyboard navigation to field
- autoComplete="off" prevents autofill
- Bots will fill this field, humans won't see it
- Server-side validation rejects non-empty values
  </action>
  <verify>
    - `bun run type-check` passes
    - Field is hidden via CSS positioning
  </verify>
  <done>
    - Honeypot field invisible to users
    - Accessible to bots (no display:none)
    - Properly typed with ContactFormData
  </done>
</task>

<task type="auto">
  <name>Task 3: Create contact form component</name>
  <files>components/forms/contact-form.tsx</files>
  <action>
Create components/forms/contact-form.tsx:

```typescript
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useRouter } from "next/navigation";
import { useToast } from "@/hooks/use-toast";
import { contactSchema, type ContactFormData } from "@/lib/validations/contact-schema";
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { HoneypotField } from "./honeypot-field";

export function ContactForm() {
  const router = useRouter();
  const { toast } = useToast();
  const createContact = useMutation(api.contacts.create);

  const form = useForm<ContactFormData>({
    resolver: zodResolver(contactSchema),
    defaultValues: {
      name: "",
      email: "",
      projectType: "wordpress",
      message: "",
      honeypot: "",
    },
  });

  async function onSubmit(data: ContactFormData) {
    try {
      const result = await createContact(data);

      if (!result.success) {
        toast({
          title: "Submission failed",
          description: "Please check your information and try again.",
          variant: "destructive",
        });
        return;
      }

      // Redirect to thank-you page on success
      router.push("/contact/thank-you");
    } catch (error) {
      console.error("Contact form error:", error);
      toast({
        title: "Something went wrong",
        description: "Please try again later.",
        variant: "destructive",
      });
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder="Your name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input type="email" placeholder="your@email.com" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="projectType"
          render={({ field }) => (
            <FormItem>
              <FormLabel>What can I help you with?</FormLabel>
              <FormControl>
                <select
                  {...field}
                  className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
                >
                  <option value="wordpress">$500 WordPress Site</option>
                  <option value="custom-web-app">Custom Web App</option>
                  <option value="consulting">Team Growth Accelerator</option>
                  <option value="other">Something Else</option>
                </select>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="message"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Tell me about your project</FormLabel>
              <FormControl>
                <textarea
                  {...field}
                  rows={5}
                  className="flex w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
                  placeholder="What are you looking to build? What's your timeline?"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <HoneypotField control={form.control} />

        <Button
          type="submit"
          className="w-full"
          disabled={form.formState.isSubmitting}
        >
          {form.formState.isSubmitting ? "Sending..." : "Send Message"}
        </Button>
      </form>
    </Form>
  );
}
```

Key patterns:
- Complete defaultValues matching Zod schema shape (critical for RHF)
- zodResolver connects Zod schema to form validation
- useMutation connects to Convex contacts.create
- Redirects to /contact/thank-you on success
- Toast for error feedback
- Disabled button during submission with loading text
- Native select styled to match shadcn (no extra dependencies)
- Honeypot field included for spam protection
  </action>
  <verify>
    - `bun run type-check` passes
    - All form fields rendered
    - Honeypot field included
  </verify>
  <done>
    - Form validates with Zod schema
    - Submits to Convex mutation
    - Redirects to thank-you on success
    - Shows error toast on failure
    - Honeypot spam protection active
  </done>
</task>

</tasks>

<verification>
Run verification:
```bash
bun run type-check
bun run lint
```

Verify component exports:
- CalendlyButton from components/calendly/
- ContactForm and HoneypotField from components/forms/
</verification>

<success_criteria>
1. CalendlyButton opens popup modal with SSR safety
2. ContactForm validates all fields with Zod
3. Form submits to Convex and redirects on success
4. Honeypot field hidden but functional
5. All type checks and lint pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-services-contact/03-03-SUMMARY.md`
</output>
