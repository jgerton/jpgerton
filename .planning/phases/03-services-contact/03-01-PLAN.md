---
phase: 03-services-contact
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - convex/schema.ts
  - lib/validations/contact-schema.ts
  - components/pricing/pricing-card.tsx
  - components/pricing/pricing-cards.tsx
autonomous: true

must_haves:
  truths:
    - "Contact form schema validates name, email, project type, message, and honeypot"
    - "Convex schema includes contactSubmissions table with required fields"
    - "Pricing cards component exists with highlighted tier support"
  artifacts:
    - path: "convex/schema.ts"
      provides: "contactSubmissions table definition"
      contains: "contactSubmissions"
    - path: "lib/validations/contact-schema.ts"
      provides: "Zod schema for contact form"
      exports: ["contactSchema", "ContactFormData"]
    - path: "components/pricing/pricing-card.tsx"
      provides: "Individual pricing card component"
      min_lines: 40
    - path: "components/pricing/pricing-cards.tsx"
      provides: "Pricing cards grid component"
      min_lines: 30
  key_links:
    - from: "lib/validations/contact-schema.ts"
      to: "zod"
      via: "import"
      pattern: "import.*from.*zod"
---

<objective>
Install required packages, extend Convex schema with contactSubmissions table, create Zod validation schema, and build pricing card components.

Purpose: Foundation for contact form storage, validation, and services page presentation.
Output: Dependencies installed, schema extended, validation ready, pricing UI components ready.
</objective>

<execution_context>
@C:\Users\jonge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jonge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-services-contact/03-CONTEXT.md
@.planning/phases/03-services-contact/03-RESEARCH.md
@convex/schema.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install packages and extend Convex schema</name>
  <files>package.json, convex/schema.ts</files>
  <action>
1. Install required packages:
   ```bash
   bun add react-calendly @convex-dev/resend
   ```

2. Extend convex/schema.ts to add contactSubmissions table:
   ```typescript
   contactSubmissions: defineTable({
     name: v.string(),
     email: v.string(),
     projectType: v.string(),
     message: v.string(),
     honeypot: v.string(),
     status: v.union(v.literal("new"), v.literal("read"), v.literal("archived")),
     createdAt: v.number(),
   })
     .index("by_status", ["status"])
     .index("by_created", ["createdAt"]),
   ```

3. Push schema changes:
   ```bash
   bunx convex dev --once
   ```

Do NOT modify existing projects or healthChecks tables.
  </action>
  <verify>
    - `bun run type-check` passes
    - `bunx convex dev --once` succeeds without errors
    - package.json includes react-calendly and @convex-dev/resend
  </verify>
  <done>
    - react-calendly and @convex-dev/resend in dependencies
    - contactSubmissions table defined with indexes
    - Schema pushed to Convex
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validation schema</name>
  <files>lib/validations/contact-schema.ts</files>
  <action>
Create lib/validations/ directory and contact-schema.ts:

```typescript
import { z } from "zod";

export const contactSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email address"),
  projectType: z.enum(["wordpress", "custom-web-app", "consulting", "other"], {
    errorMap: () => ({ message: "Please select a project type" }),
  }),
  message: z.string().min(10, "Message must be at least 10 characters"),
  honeypot: z.string().max(0, "Bot detected"),
});

export type ContactFormData = z.infer<typeof contactSchema>;
```

This schema:
- Validates name with 2 char minimum
- Validates email format
- Restricts projectType to enum values matching services
- Validates message with 10 char minimum
- Honeypot must be empty (spam protection)
  </action>
  <verify>
    - `bun run type-check` passes
    - File exports contactSchema and ContactFormData
  </verify>
  <done>
    - Zod schema validates all contact form fields
    - TypeScript type inferred from schema
    - Honeypot validation rejects non-empty values
  </done>
</task>

<task type="auto">
  <name>Task 3: Create pricing card components</name>
  <files>components/pricing/pricing-card.tsx, components/pricing/pricing-cards.tsx</files>
  <action>
Create components/pricing/ directory with two files:

**pricing-card.tsx:**
```typescript
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Check } from "lucide-react";
import { cn } from "@/lib/utils";

export interface PricingTier {
  name: string;
  price: string | null; // null = "Contact for pricing"
  description: string;
  benefits: string[];
  cta: string;
  ctaAction: "calendly" | "contact";
  highlighted?: boolean;
  badge?: string;
}

interface PricingCardProps extends PricingTier {
  onCtaClick: () => void;
  calendlySlot?: React.ReactNode; // For Calendly button injection
}

export function PricingCard({
  name,
  price,
  description,
  benefits,
  cta,
  onCtaClick,
  highlighted = false,
  badge,
  calendlySlot,
  ctaAction,
}: PricingCardProps) {
  return (
    <Card className={cn(
      "flex flex-col",
      highlighted && "border-primary shadow-lg scale-105"
    )}>
      <CardHeader className="text-center">
        {badge && (
          <Badge className="w-fit mx-auto mb-2" variant="default">
            {badge}
          </Badge>
        )}
        <CardTitle className="text-2xl">{name}</CardTitle>
        <CardDescription>{description}</CardDescription>
        <div className="mt-4">
          {price ? (
            <span className="text-4xl font-bold">{price}</span>
          ) : (
            <span className="text-xl font-semibold text-muted-foreground">Contact for pricing</span>
          )}
        </div>
      </CardHeader>
      <CardContent className="flex-1">
        <ul className="space-y-3">
          {benefits.map((benefit, i) => (
            <li key={i} className="flex gap-2">
              <Check className="h-5 w-5 text-primary shrink-0 mt-0.5" />
              <span className="text-sm">{benefit}</span>
            </li>
          ))}
        </ul>
      </CardContent>
      <CardFooter>
        {ctaAction === "calendly" && calendlySlot ? (
          calendlySlot
        ) : (
          <Button
            onClick={onCtaClick}
            className="w-full"
            variant={highlighted ? "default" : "outline"}
          >
            {cta}
          </Button>
        )}
      </CardFooter>
    </Card>
  );
}
```

**pricing-cards.tsx:**
```typescript
"use client";

import { PricingCard, type PricingTier } from "./pricing-card";

interface PricingCardsProps {
  tiers: PricingTier[];
  onContactClick: () => void;
  renderCalendlyButton: (tier: PricingTier) => React.ReactNode;
}

export function PricingCards({ tiers, onContactClick, renderCalendlyButton }: PricingCardsProps) {
  return (
    <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
      {tiers.map((tier) => (
        <PricingCard
          key={tier.name}
          {...tier}
          onCtaClick={onContactClick}
          calendlySlot={tier.ctaAction === "calendly" ? renderCalendlyButton(tier) : undefined}
        />
      ))}
    </div>
  );
}
```

Key decisions:
- PricingCard is presentational, receives calendlySlot for CTA injection
- PricingCards handles grid layout and passes callback for contact actions
- highlighted tier scales up slightly with shadow
- Benefits use Check icon from lucide-react
- Flexible price display (string or "Contact for pricing")
  </action>
  <verify>
    - `bun run type-check` passes
    - Both files export correctly
    - No ESLint errors
  </verify>
  <done>
    - PricingCard renders individual tier with benefits list
    - PricingCards renders responsive 3-column grid
    - Highlighted tier visually distinguished
    - Calendly button injection supported via slot pattern
  </done>
</task>

</tasks>

<verification>
Run all verification commands:
```bash
bun run type-check
bun run lint
```

Check package.json for new dependencies:
- react-calendly
- @convex-dev/resend

Verify convex/schema.ts contains contactSubmissions table.
</verification>

<success_criteria>
1. Dependencies installed: react-calendly and @convex-dev/resend in package.json
2. Convex schema extended with contactSubmissions table and indexes
3. Zod validation schema exports contactSchema and ContactFormData type
4. Pricing components ready for services page assembly
5. All type checks and lint pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-services-contact/03-01-SUMMARY.md`
</output>
