---
phase: 18-content-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/projects/[slug]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Project detail page shows linked case study data from Convex when a published case study exists for the project"
    - "Project detail page shows a fallback 'Project Highlights' section derived from project fields when no case study is linked"
    - "Case study metrics display as formatted strings (e.g., 'Load Time: 1.2s') in the CaseStudyVisual component"
    - "Only the first (most recent) case study is shown when multiple exist for a project"
    - "The misleading 'Future enhancement' comment is removed"
  artifacts:
    - path: "app/projects/[slug]/page.tsx"
      provides: "Dynamic case study display with Convex query and fallback"
      min_lines: 200
  key_links:
    - from: "app/projects/[slug]/page.tsx"
      to: "api.caseStudies.getByProject"
      via: "fetchQuery in Server Component"
      pattern: "fetchQuery.*caseStudies\\.getByProject"
    - from: "app/projects/[slug]/page.tsx"
      to: "components/portfolio/case-study-visual.tsx"
      via: "CaseStudyVisual component props"
      pattern: "CaseStudyVisual"
---

<objective>
Replace the hardcoded derived case study data on project detail pages with dynamic Convex queries. When a published case study is linked to a project, display its real data. When no case study exists, show a fallback "Project Highlights" section using project fields.

Purpose: Fulfills CASE-06 (project pages display linked case study) and CASE-07 (real data replaces placeholder content). This is the core content integration for the portfolio showcase.

Output: Updated `app/projects/[slug]/page.tsx` with dynamic case study fetching and fallback logic.
</objective>

<execution_context>
@C:\Users\jonge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jonge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-content-integration/18-CONTEXT.md
@.planning/phases/18-content-integration/18-RESEARCH.md

@app/projects/[slug]/page.tsx
@convex/caseStudies.ts (reference: getByProject query returns published, non-deleted case studies with coverImageUrl)
@components/portfolio/case-study-visual.tsx (reference: CaseStudyVisualProps interface)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate dynamic case study query with fallback</name>
  <files>app/projects/[slug]/page.tsx</files>
  <action>
Modify the project detail page Server Component to fetch case study data from Convex and display it dynamically, with a fallback for projects that have no linked case study.

**Changes to make:**

1. **Add case study query** after the existing project fetch (line 63):
   ```typescript
   const caseStudies = await fetchQuery(api.caseStudies.getByProject, {
     projectId: project._id,
   });
   const caseStudy = caseStudies[0]; // Show only the first (most recent) one
   ```

2. **Replace the entire `caseStudyData` const block** (lines 75-93) with conditional logic:

   When `caseStudy` exists (linked published case study found):
   ```typescript
   const caseStudyData = {
     problem: {
       heading: caseStudy.problemHeading,
       content: caseStudy.problemContent,
     },
     solution: {
       heading: caseStudy.solutionHeading,
       content: caseStudy.solutionContent,
     },
     results: {
       heading: caseStudy.resultsHeading,
       content: caseStudy.resultsContent,
       metrics: caseStudy.metrics.map(
         (m) => `${m.label}: ${m.value}`
       ),
     },
   };
   ```

   When `caseStudy` is null/undefined (no linked case study):
   ```typescript
   const caseStudyData = {
     problem: {
       heading: "The Challenge",
       content: project.descriptionLong || project.description,
     },
     solution: {
       heading: "The Approach",
       content:
         "Built with a modern tech stack focused on performance, maintainability, and great user experience.",
     },
     results: {
       heading: "The Result",
       content:
         "A polished application that demonstrates professional web development capabilities.",
       metrics: project.techStack.slice(0, 3).map((tech) => `Built with ${tech}`),
     },
   };
   ```
   This fallback is intentionally similar to the current derived data - it uses project fields as a sensible default.

3. **Update the section heading** in the JSX (line 139):
   - When `caseStudy` exists: Use "Case Study" as the heading
   - When no case study: Use "Project Highlights" as the heading
   Example:
   ```tsx
   <h2 className="font-serif font-medium text-h2 leading-tight mb-lg">
     {caseStudy ? "Case Study" : "Project Highlights"}
   </h2>
   ```

4. **Remove the misleading comment** on lines 75-76:
   ```
   // Derive case study data from available project fields
   // Future enhancement: add dedicated case study fields to Convex schema
   ```
   Replace with a clear comment explaining the conditional logic:
   ```
   // Use linked case study data if available, otherwise derive from project fields
   ```

5. **Do NOT change** the CaseStudyVisual component usage or any other part of the page. The component already accepts the exact shape we are constructing.

**Key constraint:** This is a Server Component using `fetchQuery`. The `api.caseStudies.getByProject` query is already public (no auth required) and returns published, non-deleted case studies sorted by displayOrder ascending.

**Metrics data transformation:** The Convex schema stores metrics as `{ label: string, value: string }[]` but CaseStudyVisual expects `string[]`. The `.map((m) => \`${m.label}: ${m.value}\`)` transformation handles this.
  </action>
  <verify>
Run `bun run type-check` inside the Docker container. The page should compile without TypeScript errors.
Run `bun run lint` to confirm no lint issues in the modified file.
Run `bun run build` to verify the Server Component renders correctly at build time.
  </verify>
  <done>
Project detail page dynamically fetches case study data via `fetchQuery(api.caseStudies.getByProject)`. When a published case study is linked, its real data (headings, content, metrics) displays via CaseStudyVisual. When no case study exists, project fields provide a fallback "Project Highlights" section. The "Future enhancement" comment is removed.
  </done>
</task>

</tasks>

<verification>
1. `bun run type-check` passes
2. `bun run lint` passes
3. `bun run build` succeeds (Server Component fetches render at build time)
4. The `fetchQuery(api.caseStudies.getByProject, { projectId: project._id })` call exists
5. Metrics transformation maps `{ label, value }` objects to `"Label: Value"` strings
6. Fallback data uses project.descriptionLong/description and techStack
7. Section heading is "Case Study" when data exists, "Project Highlights" when fallback
8. The "Future enhancement: add dedicated case study fields" comment is gone
</verification>

<success_criteria>
- Dynamic case study query integrated into project detail Server Component
- First case study from getByProject used (most recent by displayOrder)
- Fallback to project-derived data when no case study linked
- Metrics properly transformed from object array to string array
- Section heading changes based on data source (Case Study vs Project Highlights)
- No misleading placeholder comments remain
- Type checks and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-content-integration/18-02-SUMMARY.md`
</output>
